---
layout: post
license: Public Domain
---

===========================================
OAuth 3.0: The Sane and Simple Way To Do It
===========================================

.. raw:: html

  <div class="float-right">
    <a href="http://oauth.net"><img
      src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Oauth_logo.svg/150px-Oauth_logo.svg.png" /></a>
  </div>

I'm a big fan of `OAuth <http://oauth.net/>`_ and I've done my fair share of
promoting it -- from writing various open source client libraries to
implementing services using it. However, the `OAuth 2.0 spec
<http://tools.ietf.org/html/draft-ietf-oauth-v2-08>`_ just takes the piss.

It's overly prescriptive, inconsistent and poorly written -- the worst that one
could hope for from an emerging standard. And it sucks so much that I've yet to
find a single conformant implementation by a major service provider.

Take Facebook. They boldly claim `OAuth 2.0 support
<http://developers.facebook.com/docs/authentication/>`_ and yet ignore most of
it:

* The spec states that the ``oauth_token`` parameter be used when accessing a
  protected resource. Facebook use the ``access_token`` parameter name instead.

* The spec states that certain requests MUST include the client ``type`` and
  ``grant_type`` parameters. Facebook enforces no such requirement.

* The spec states that clients MUST be able to authenticate themselves using
  both HTTP basic auth and URI query parameters. Facebook only support the
  latter.

I could go on, but I'm sure you get the picture. The irony here is that `David
Recordon <http://davidrecordon.com/>`_ from Facebook is actually one of the
co-authors of the spec. And before anyone starts bashing Facebook for ignoring
standards, please read `the latest draft of the spec
<http://tools.ietf.org/html/draft-ietf-oauth-v2-08>`_ -- it is shockingly
convoluted for such a simple thing like OAuth.

.. more

As it is, what we're seeing is the emergence of incompatible and incomplete
implementations by service providers. And when even the whiz kids at GitHub have
`issues implementing OAuth 2.0
<http://support.github.com/discussions/api/28-oauth2-busy-developers-guide>`_,
it's time to re-evaluate the specification.

Furthermore, while the spec goes on about rarely used `SAML assertions
<http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language#SAML_Assertions>`_,
it fails to standardise for service discovery, client registration and
management. Sites like Disqus and Ning make good use of Facebook's `Create
Application API
<http://wiki.developers.facebook.com/index.php/Create_Application_API>`_ -- it'd
be nice if this was standardised!

.. raw:: html

  <div class="center">
    <a href="http://wiki.developers.facebook.com/index.php/Create_Application_API"><img
      src="http://img.skitch.com/20100629-1j8cf13m5669gg31mm86gfjc9j.png" /></a>
  </div>

So, in the interest of simplifying life for developers everywhere, I hereby
present OAuth 3.0 -- a more comprehensive alternative to the latest OAuth 2.0
draft. It is so simple that even an idiot like me could do a complete
implementation in about 200 lines of Python code:

* http://ampify.it/tentapp.html#oauth

Anyways, let me know what you think -- especially if you've already experienced
the pain of implementing OAuth. Thanks!

.. class:: block-section

**OAuth 3.0**

OAuth is a simple way for Client Applications to perform authorised actions on
behalf of a User on remote Service Providers.

**Service Discovery**

Service Providers announce their support for OAuth by publishing a
``/.well-known/oauth.json`` file on their website. This file lives inside the
``.well-known`` directory introduced by `[RFC 5796]
<http://tools.ietf.org/html/rfc5785>`_ and is encoded in the JSON format `[RFC
4627] <http://tools.ietf.org/html/rfc4627>`_. So for a Service Provider
supporting OAuth 3.0:

.. syntax:: bash

  $ curl https://www.serviceprovider.com/.well-known/oauth.json

We'd find something like:

.. syntax:: javascript

  {
    "auth_endpoint": "http://www.serviceprovider.com/oauth/authorize",
    "auth_management_endpoint": "https://www.serviceprovider.com/oauth/manage",
    "client_terms": "http://www.serviceprovider.com/terms",
    "client_management_endpoint": "https://www.serviceprovider.com/oauth/clients",
    "reg_challenge": "sha-1:20:473dfb39-198e-4082-bac1-c00cb868e3c4",
    "reg_endpoint": "https://www.serviceprovider.com/oauth/register",
    "token_endpoint": "https://www.serviceprovider.com/oauth/token",
    "version": "3.0.0"
  }

The JSON object could include other properties, but the following string
properties MUST be present:

* The ``auth_endpoint`` defines the URL which Client Apps will direct a User to
  -- in order for the User to authorize access.

* The ``auth_management_endpoint`` defines the HTTPS URL where Users will be
  able to manage the various applications that they have authorized.

* The ``client_terms`` defines the URL for the Service Provider's terms of use
  and policies for Client Apps.

* The ``client_management_endpoint`` defines the HTTPS URL where Users will be
  able to manage the various Client Apps that they have registered.

* The ``reg_challenge`` defines a hashcash challenge spec for apps to use when
  registering clients programmatically. This MUST be of the format
  ``<hash-algorithm>:<hashcash-bits>:<uuid>``.

* The ``reg_endpoint`` defines the HTTPS URL where Client Apps will be able to
  register with the Service Provider.

* The ``token_endpoint`` defines the HTTPS URL that Client Apps will communicate
  with -- in order to get or refresh an authorized access token.

* The ``version`` defines the `Semantic Version <http://semver.org/>`_ of the
  OAuth Protocol that the Service Provider is currently supporting.

  .. syntax:: coffeescript

    current_version: "3.0.0"

**API Overview**

Except for HTTP redirects, all communication between Client Apps and Service
Providers MUST take place over HTTPS connections -- this is vital for security.
There are four OAuth-specific APIs exposed at the following Service Provider
endpoints:

* ``auth_management_endpoint``
* ``client_management_endpoint``
* ``reg_endpoint``
* ``token_endpoint``

They accept URL-encoded parameters via HTTP GET or POST with the
``application/x-www-form-urlencoded`` content type and all successful calls
return a JSON encoded response with a ``200 OK`` HTTP status code and
``application/json`` content type.

Unsuccessful calls will have either ``4xx`` or ``5xx`` HTTP status codes and
these may or may not have JSON-encoded error responses -- this can be determined
by looking for ``application/json`` in the ``content-type`` response header.

The structure of the JSON-encoded error responses is not standardised beyond the
required presence of an ``error`` property. This property can be of arbitrary
type and can be accompanied by other properties, e.g.

.. syntax:: javascript

  {
    "error": "The client_secret parameter was not specified.",
    "error_type": "ValueError"
  }

Or perhaps something like:

.. syntax:: javascript

  {
    "error": {
      "type": "InvalidClientCredentials",
      "message": "Matching client credentials could not be found."
    }
  }

It is left up to the Service Providers to be as helpful or unhelpful as they
desire to be with their error responses.

**Client Registration**

Client Apps register with the Service Provider via the ``reg_endpoint``. This
could be done either manually or programmatically. Manual registration involves
the app developer authenticating with the Service Provider and then visiting the
``reg_endpoint`` using their browser.

Alternatively, it could be done programmatically by POSTing to the
``reg_endpoint`` which accepts the following parameters:

* ``name`` -- the name of the Application being registered. [required]

* ``website_url`` -- the website for the Application. [required]

* ``description`` -- a brief description of the Application. [optional]

* ``hashcash`` -- a valid hashcash payment for registering with the Service
  Provider. [required]

* ``redirect_url`` -- where to redirect requests.

  * If the Client App will never be making OAuth requests of the ``user_agent``
    type, then this parameter is optional.

  * Otherwise, it is required and should be HTTPS.a

And responds with a JSON object with the following string properties:

*  ``client_id`` -- 

* ``client_secret``

So, for example, if one did:

.. syntax:: bash

  $ curl -d 'name=Awesome%20App' -d 'url=http%3A//www.awesomeapp.com' \
    -d 'description=This%20lets%20you%20do%20awesome%20things' \
    -d 'hashcash=' \
    https://www.serviceprovider.com/oauth/register

Then a successful response would look something like:

.. syntax:: javascript

  {
    "client_id": "c6cbeb7f4ede64c1615ff2d27307030f9612",
    "client_secret": "4d1e7bd053385838838d5c2dea60b531a2c7"
  }

The ``:client_registration`` scope.
A data structure like the following is recommended:

.. syntax:: python

  class OAuthClient(db.Model):
      created = db.DateTimeProperty()
      name = db.StringProperty()
      description = db.TextProperty()
      website = db.StringProperty()
      redirect = db.StringProperty()
      owner = db.StringProperty(default='@anonymous')
      secret = db.StringProperty()

And, for the love of the Gods of SGML, please escape the angle brackets and
related characters when displaying client-provided data to end users, e.g.

.. syntax:: python

  def escape(s)
      return s.replace("&", "&amp;").replace("<", "&lt;").replace(
          ">", "&gt;").replace('"', "&quot;")


**App Request**

.. syntax:: python

  def authorize(
    client_id, redirect_uri, scope, state=None, request_type='application'
    ) -> HTTPRedirect



Scopes beginning with ``:`` are for use by the OAuth-protocol related API calls.
Two have already been defined:

* ``:auth_management```
* ``:client_management```
* ``:client_registration``

Service Providers MUST not define such colon-prefixed scopes for their own use
as they're reserved for future versions of the OAuth protocol.

**User Agent**

And:

.. syntax:: javascript

  var randomString = (Math.random() * 0x100000000).toString(16);
  document.cookie = 'expectedState=' + randomString;

A timing-independent string comparison mechanism should be used so as to avoid
`timing attacks
<http://rdist.root.org/2009/05/28/timing-attack-in-google-keyczar-library/>`_:

.. syntax:: python

    def constant_time_string_compare(s1, s2, ord=ord):
        """Return whether two strings are equal."""

        if len(s1) != len(s2):
            return False
        total = 0
        for x, y in zip(s1, s2):
            total |= ord(x) ^ ord(y)
        return total == 0
