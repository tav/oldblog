---
layout: post
license: Public Domain
---

===========================================
OAuth 3.0: The Sane and Simple Way To Do It
===========================================

.. raw:: html

  <div class="float-right">
    <a href="http://oauth.net"><img
      src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Oauth_logo.svg/150px-Oauth_logo.svg.png" /></a>
  </div>

I'm a big fan of `OAuth <http://oauth.net/>`_ and I've done my fair share of
promoting it -- from writing various open source client libraries to
implementing services using it. However, the `OAuth 2.0 spec
<http://tools.ietf.org/html/draft-ietf-oauth-v2-08>`_ is a bit of a mess.

It's overly prescriptive, inconsistent and poorly written -- the worst that one
could hope for from an emerging standard. And it sucks so much that I've yet to
find a single conformant implementation by a major service provider.

Take Facebook. They boldly claim `OAuth 2.0 support
<http://developers.facebook.com/docs/authentication/>`_ and yet ignore most of
it:

* The spec states that the ``oauth_token`` parameter be used when accessing a
  protected resource. Facebook use the ``access_token`` parameter name instead.

* The spec states that certain requests MUST include the client ``type`` and
  ``grant_type`` parameters. Facebook enforces no such requirement.

* The spec states that clients MUST be able to authenticate themselves using
  both HTTP basic auth and URI query parameters. Facebook only support the
  latter.

I could go on, but I'm sure you get the picture. The irony here is that `David
Recordon <http://davidrecordon.com/>`_ from Facebook is actually one of the
co-authors of the spec. And before anyone starts bashing Facebook for ignoring
standards, please read `the latest draft of the spec
<http://tools.ietf.org/html/draft-ietf-oauth-v2-08>`_ -- it is shockingly
convoluted for such a simple thing like OAuth.

.. more

As it is, what we're seeing is the emergence of incompatible and incomplete
implementations by service providers. And when even the whiz kids at GitHub have
`issues implementing OAuth 2.0
<http://support.github.com/discussions/api/28-oauth2-busy-developers-guide>`_,
it's time to re-evaluate the specification.

Furthermore, while the spec goes on about rarely used `SAML assertions
<http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language#SAML_Assertions>`_,
it fails to standardise `service discovery <http://oauth.net/discovery/1.0/>`_,
client registration, management, etc. Sites like Disqus and Ning make good use
of APIs like Facebook's `Create Application API
<http://wiki.developers.facebook.com/index.php/Create_Application_API>`_ -- it'd
be nice if this was standardised!

.. raw:: html

  <div class="center">
    <a href="http://wiki.developers.facebook.com/index.php/Create_Application_API"><img
      src="http://img.skitch.com/20100629-1j8cf13m5669gg31mm86gfjc9j.png" /></a>
  </div>

So, in the interest of simplifying life for developers everywhere, I hereby
present OAuth 3.0 -- a more comprehensive alternative to the latest OAuth 2.0
draft. It is so simple that even an idiot like me could do a complete
client/server implementation in about 300 lines of Python code.

Anyways, let me know what you think -- especially if you've already experienced
the pain of implementing OAuth. Thanks!

.. class:: block-section

**OAuth 3.0**

OAuth allows Applications to perform authorized actions on behalf of a User on
remote Service Providers. The core process is quite straightforward:

1. Applications register with the Service Provider and are issued with a
   ``client_id`` and ``client_secret``.

2. Applications use one of three different mechanisms to get hold of an
   authorized ``access_token`` for a User.

3. Applications use the ``access_token`` to perform actions on behalf of the
   User.

**Service Discovery**

Service Providers announce their support for OAuth by publishing a
``/.well-known/oauth.json`` file on their website. This file lives inside the
``.well-known`` directory introduced by `[RFC 5796]
<http://tools.ietf.org/html/rfc5785>`_ and is encoded in the JSON format `[RFC
4627] <http://tools.ietf.org/html/rfc4627>`_. So for a Service Provider
supporting OAuth 3.0:

.. syntax:: bash

  $ curl https://www.serviceprovider.com/.well-known/oauth.json

We'd find something like:

.. syntax:: javascript

  {
    "auth_endpoint": "http://www.serviceprovider.com/oauth/authorize",
    "auth_management_endpoint": "https://www.serviceprovider.com/oauth/apps",
    "client_management_endpoint": "https://www.serviceprovider.com/oauth/clients",
    "client_registration_challenge": "sha-1:20:serviceprovider.com",
    "client_registration_endpoint": "https://www.serviceprovider.com/oauth/register",
    "terms_of_use": "http://www.serviceprovider.com/terms",
    "token_endpoint": "https://www.serviceprovider.com/oauth/token",
    "version": "3.0.0"
  }

The JSON object could include other properties, but the following string
properties MUST be present:

* The ``auth_endpoint`` defines the HTTP or HTTPS URI `[RFC 3986]
  <http://tools.ietf.org/html/rfc3986>`_ which Apps will direct a User to -- in
  order for the User to authorize access.

* The ``auth_management_endpoint`` defines the HTTPS URI where Users will be
  able to manage the various Apps that they have authorized.

* The ``client_management_endpoint`` defines the HTTPS URI where Users will be
  able to manage the various App Clients that they have registered.

* The ``client_registration_challenge`` defines a hashcash challenge spec for
  Apps to use when registering. This MUST be of the format
  ``<hash-algorithm>:<hashcash-bits>:<provider-id>`` where the ``provider-id``
  is some form of unique identifier for the Service Provider -- like its domain
  name.

* The ``client_registration_endpoint`` defines the HTTPS URI where Apps will be
  able to register and be issued with ``client_id`` and ``client_secret`` codes.

* The ``terms_of_use`` defines the HTTP or HTTPS URI for the Service Provider's
  terms of use and policies for Apps.

* The ``token_endpoint`` defines the HTTPS URI that Apps will communicate with
  -- in order to get or refresh an authorized ``access_token``.

* The ``version`` defines the `Semantic Version <http://semver.org/>`_ of the
  OAuth Protocol that the Service Provider is currently supporting.

  .. syntax:: coffeescript

    current_version: "3.0.0"

**API Overview**

Except for HTTP redirects, all communication between Client Apps and Service
Providers MUST take place over HTTPS connections -- this is vital for security.
There are four OAuth-specific APIs exposed at the following Service Provider
endpoints:

* ``auth_management_endpoint``
* ``client_management_endpoint``
* ``client_registration_endpoint``
* ``token_endpoint``

They accept URI-encoded parameters via HTTP GET or POST with the
``application/x-www-form-urlencoded`` content type and all successful calls
return a JSON encoded response with a ``200 OK`` HTTP status code and
``application/json`` content type.

Unsuccessful calls will have either ``4xx`` or ``5xx`` HTTP status codes and
these may or may not have JSON-encoded error responses -- this can be determined
by looking for ``application/json`` in the ``content-type`` response header.

The structure of these JSON-encoded error responses are not standardized beyond
the required presence of an ``error`` property. This property can be of
arbitrary type and can be accompanied by other properties, e.g.

.. syntax:: javascript

  {
    "error": "The client_secret parameter was not specified.",
    "error_type": "ValueError"
  }

Or even something like:

.. syntax:: javascript

  {
    "error": {
      "type": "InvalidClientCredentials",
      "message": "Matching client credentials could not be found."
    }
  }

It is left up to the Service Providers to be as helpful or unhelpful as they
desire to be with their error responses.

**Client Registration**

Apps register with the Service Provider via the ``client_registration_endpoint``
in order to be issued with ``client_id`` and ``client_secret`` codes. This could
be done either manually or programmatically. Manual registration involves the
app developer authenticating with the Service Provider and then visiting the
endpoint using their browser.

Alternatively, it could be done programmatically by POSTing to the
``client_registration_endpoint`` which accepts the following parameters:

* ``name`` -- the name of the Application encoded as a UTF-8 string `[RFC 3629]
  <http://tools.ietf.org/html/rfc3629>`_ with a maximum length of 100 bytes.
  REQUIRED.

* ``website`` -- the website URI for the Application with a maximum length of
  200 bytes. OPTIONAL.

* ``description`` -- a brief description of the Application encoded as a UTF-8
  string with a maximum length of 500 bytes. OPTIONAL.

* ``organization`` -- the name of the Organization behind the Application
  encoded as a UTF-8 string with a maximum length of 100 bytes. OPTIONAL.

* ``accept_terms`` -- this MUST be set to ``yes`` and indicates acceptance of
  the Service Provider's ``terms_of_use``. REQUIRED.

* ``hashcash`` -- a valid hashcash payment for registering with the Service
  Provider with a maximum length of 100 bytes. See below for more info.
  REQUIRED.

* ``redirect_base_uri`` -- the expected prefix of the "callback" URI to redirect
  to after a User has authorized an OAuth request. Maximum length of 200 bytes.

  * If the App will only use the Standard Flow OAuth Request, then it is
    OPTIONAL and will only be checked if set and can be either an HTTP or HTTPS
    URI.

  * Otherwise, this parameter is REQUIRED and MUST be an HTTPS URI.

A successful registration will result in a JSON response with the following
string properties:

* ``client_id``

* ``client_secret``

So, for example, if one did:

.. syntax:: bash

  $ curl -d 'name=Awesome%20App' -d 'accept_terms=yes' \
    -d 'hashcash=1:20:100629:serviceprovider.com::e302ac179846:18b51f' \
    https://www.serviceprovider.com/oauth/register

Then a successful response would look something like:

.. syntax:: javascript

  {
    "client_id": "c6cbeb7f4ede64c1615ff2d27307030f9612",
    "client_secret": "4d1e7bd053385838838d5c2dea60b531a2c7"
  }

In order to be used as "primary keys" by Applications, the returned
``client_id`` and ``client_secret`` values MUST be less than 100 bytes long and
be composed of characters in the range
``abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-0123456789``.

If a random number generator is used to generate the values, bear in mind that
18 random bytes (which is 36 bytes long in hex-encoding) should be more than
enough -- and 36 random bytes gives you more permutations than current
estimations of the number of atoms in the universe.

The ``hashcash`` payment value is used to mitigate against any resource
exhaustion attacks against Service Providers -- who have to provide long-term
storage of the registered values. The use of `hashcash <http://hashcash.org/>`_
forces an Application to use up some CPU cycles as a proof of work.

The hashcash is generated according to the Service Provider's
``client_registration_challenge`` property which is of the format:

* ``<hash-algorithm>:<hashcash-bits>:<provider-id>``

The ``hash-algorithm`` defines the algorithm to be used (normally SHA-1 `[RFC
3174] <http://tools.ietf.org/html/rfc3174>`_), the ``provider-id`` defines a
unique identifier for the Service Provider (normally its domain name) and the
``hashcash-bits`` specifies the number of leading bits of the ``hashcash``
digest which must be zero for it to be valid.

Applications generate ``hashcash`` in a manner similar to:

.. syntax:: python

  algorithm, bits, provider_id = challenge.split(':')
  if algorithm == 'sha-1':
      hash = sha1
  elif algorithm == 'sha-256':
      hash = sha256
  else:
      raise ValueError("Unknown hash algorithm: %s" % algorithm)
  bits = int(bits)
  hashcash = generate_hashcash(provider_id, bits, hash)

Where ``generate_hashcash()`` creates an appropriate `version 1 format hashcash
stamp <http://www.hashcash.org/docs/hashcash.html#stamp_format__version_1_>`_:

.. syntax:: python

  from binascii import hexlify
  from datetime import datetime
  from hashlib import sha1
  from math import ceil
  from os import urandom
  from time import time

  def generate_hashcash(resource, bits=20, hash=sha1):
      date = datetime.utcnow().strftime("%y%m%d")
      rand = hexlify(urandom(6)) # a 48-bit random string
      prefix = "1:%s:%s:%s::%s:" % (bits, date, resource, rand)
      counter = 0
      n = int(ceil(bits/4.)) # rounds up to the closest 4-bits
      lead_zeros = '0' * n
      while 1:
          digest = hash("%s%x" % (prefix, counter)).hexdigest()
          if digest[:n] == lead_zeros:
              return "%s%x" % (prefix, counter)
          counter += 1

Service Providers verify that the ``hashcash`` is valid and hasn't been used
before with something like:

.. syntax:: python

  def valid_hashcash(hashcash, resource, bits=20, hash=sha1):
      n = int(ceil(bits/4.))
      digest = hash(hashcash).hexdigest()
      if digest[:n] != ('0' * n):
          return False
      _, _bits, date, _resource, _, _, _ = hashcash.split(':')
      if resource != _resource:
          return False
      timestamp = int(datetime(
          int(date[:2]) + 2000, # map a 2-digit YY into a YYYY
          int(date[2:4]),
          int(date[4:6])
          ).strftime('%s'))
      now = time()
      time_difference = now - timestamp
      # allow for clock skew of up to 3 days
      if not (-259200 <= time_difference <= 259200):
          return False
      # check if the hashcash has been used before
      stored_hashcash = HashCash.get_by_key_name(hashcash)
      if stored_hashcash:
          raise ValueError("The given hashcash has already been used.")
      db.put(HashCash(key_name=hashcash, created=timestamp))
      return True

So, from the previous example, we'd get:

.. syntax:: pycon

  >>> valid_hashcash(
  ...     '1:20:100629:serviceprovider.com::e302ac179846:18b51f',
  ...     'serviceprovider.com'
  ... )
  True

The recommended data structure for storing hashcash for checking against double
spending is something like:

.. syntax:: python

  # primary key: hashcash
  class HashCash(db.Model):
      created = db.IntegerProperty() # UNIX timestamp

Service Providers can reclaim used space by removing all entries older than 3
days. And, similarly, the recommended data structure for storing registered
clients is something like:

.. syntax:: python

  # primary key: client_id
  class OAuthClient(db.Model):
      created = db.IntegerProperty()
      name = db.StringProperty()
      description = db.TextProperty()
      organization = db.TextProperty()
      website = db.ByteStringProperty()
      redirect = db.ByteStringProperty()
      owner = db.StringProperty(default='')
      secret = db.ByteStringProperty()
      last_used = db.IntegerProperty()

The ``owner`` field is used to represent the User who authorized the
registration. This should be set to a null value for "anonymous registrations"
or to some representation of the User if there was a valid ``access_token`` for
the ``:client_registration`` scope accompanying the registration call.

Anonymous registrations are expected to be short-lived and Service Providers may
remove them after a minimum of 30 days of inactivity. The presence of the
``last_used`` field is intended to be used to help with such clean up.

And for the love of the Gods of SGML, Service Providers, please escape angle
brackets and related characters when displaying the submitted data to end users,
e.g.

.. syntax:: python

  def escape(s)
      return s.replace("&", "&amp;").replace("<", "&lt;").replace(
          ">", "&gt;").replace('"', "&quot;")


Don't be `like
<http://www.davidnaylor.co.uk/massive-twitter-cross-site-scripting-vulnerability.html>`_
`Twitter
<http://praetorianprefect.com/archives/2010/06/persistent-xss-on-twitter-com/>`_.

**Authorization Request**

.. syntax:: python

  def authorize(
    client_id, redirect_uri, scope, state=None, request_type='application'
    ) -> HTTPRedirect



Scopes beginning with ``:`` are for use by the OAuth-protocol related API calls.
Two have already been defined:

* ``:auth_management```
* ``:client_management```
* ``:client_registration``

Service Providers MUST not define such colon-prefixed scopes for their own use
as they're reserved for future versions of the OAuth protocol.

**User Agent**

And:

* ``display`` -- either ``default`` or ``compact``

.. syntax:: javascript

  var randomString = (Math.random() * 0x100000000).toString(16);
  document.cookie = 'expectedState=' + randomString;

A timing-independent string comparison mechanism should be used so as to avoid
`timing attacks
<http://rdist.root.org/2009/05/28/timing-attack-in-google-keyczar-library/>`_:

.. syntax:: python

    def constant_time_string_compare(s1, s2, ord=ord):
        """Return whether two strings are equal."""

        if len(s1) != len(s2):
            return False
        total = 0
        for x, y in zip(s1, s2):
            total |= ord(x) ^ ord(y)
        return total == 0

**Using Access Tokens**

Once an ``access_token`` has been obtained, the Application should store it
securely and use it to perform actions on a User's behalf. It is intended to be
compatible with whatever APIs the Service Provider offers and MUST only be sent
to HTTPS URIs.

The last point is worth re-iterating -- the ``access_token`` MUST only be sent
across HTTPS channels. Service Provides MUST NOT process access tokens sent in
the clear. Processing power is now cheap enough to warrant such a requirement in
the interest of security.

For requests supporting OAuth, Service Providers MUST accept:

* a URI-encoded ``access_token`` parameter as part of either the request URI or
  as part of the request body for POST requests. If both are present, then the
  value sent in the request URI should be discarded.

* a ``Access-Token`` request header with the access token as the value (without
  any URI encoding).

If both are present, then the URI-encoded parameter should be discarded.

Here's an example GET request:

.. syntax:: bash

  $ curl "https://www.serviceprovider.com/news?type=feed&access_token=abcd"

And another:

.. syntax:: bash

  $ curl -G -d "access_token=abcd" \
    https://www.serviceprovider.com/messages

And yet another:

.. syntax:: bash

  $ curl -H "Access-Token: abcd" \
    https://www.serviceprovider.com/messages

Here's an example POST request with the ``content-type`` set to
``application/x-www-form-urlencoded``:

.. syntax:: bash

  $ curl -d 'text=Hello%20world' -d 'access_token=abcd' \
    https://www.serviceprovider.com/message

Here's an example POST request with the ``content-type`` set to
``multipart/form-data``:

.. syntax:: bash

  $ curl -F 'file=@profile.jpg' -F 'access_token=abcd' \
    https://www.serviceprovider.com/profile-image

And another:

.. syntax:: bash

  $ curl -F 'file=@profile.jpg' -H "Access-Token: abcd" \
    https://www.serviceprovider.com/profile-image

For requests needing authorization, Service Providers should look for and
validate the ``access_token`` for the appropriate ``scope`` before returning a
successful response. If the token has expired, then the Service Provider MUST
respond with a ``412 Precondition Failed`` HTTP status code.

If the ``access_token`` is invalid for any other reason, then the Service
Provider MUST respond with a ``401 Not Authorized`` HTTP status code. The
``content-type`` header of this response can be whatever and need not contain a
JSON object with a descriptive ``error`` property -- although that would be
helpful.

**Client Management**

Apps can manage client registrations via the ``client_management_endpoint``.
This could be done either manually or programmatically. Manual management
involves the app developer authenticating with the Service Provider and then
visiting the endpoint using their browser.

Alternatively, it could be done programmatically by POSTing to the
``client_management_endpoint`` which accepts the following parameters:
